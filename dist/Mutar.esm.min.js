/**
 * [Mutar]{@link https://github.com/UmamiAppearance/MutableTypedArrayJS}
 *
 * @version 0.1.5
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license GPL-3.0
 *
 * Mutar is both toolkit a to interact with typed arrays and 
 * "modify" them and a constructor of a special object. Or  let"s
 * say a kit to emulate modification. Each "mutation" actually 
 * creates a new array every time.
 * This comes to a price of course. Each time the array "changes",
 * a new array is allocated in memory. Keep that in mind when using
 * it.
 * Mutar objects and tools on the other hand are a very convenient way 
 * to handle binary data. If constructed, the array behaves pretty 
 * much as a regular array. You can concatenate, pop, shift, unshift...
 * On top of that the type can be changed from - let"s say - Uint8 to 
 * Float64. Also zero padding can get trimmed. 
 */
const t={getSysEndianness:()=>{const t=new Uint16Array([1]),r=new Uint8Array(t.buffer);return Boolean(r.at(0))},ArrayTypes:{Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,BigInt64Array:BigInt64Array,BigUint64Array:BigUint64Array},ArrayShortCuts:{Int8:"Int8Array",Uint8:"Uint8Array",Clamped:"Uint8ClampedArray",Int16:"Int16Array",Uint16:"Uint16Array",Int32:"Int32Array",Uint32:"Uint32Array",Float32:"Float32Array",Float64:"Float64Array",BigInt:"BigInt64Array",BigUint:"BigUint64Array"},ViewMethods:{Int8Array:{get:"getInt8",set:"setInt8"},Uint8Array:{get:"getUint8",set:"setUint8"},Uint8ClampedArray:{get:"getUint8",set:"setUint8"},Int16Array:{get:"getInt16",set:"setInt16"},Uint16Array:{get:"getUint16",set:"setUint16"},Int32Array:{get:"getInt32",set:"setInt32"},Uint32Array:{get:"getUint32",set:"setUint32"},Float32Array:{get:"getFloat32",set:"setFloat32"},Float64Array:{get:"getFloat64",set:"setFloat64"},BigInt64Array:{get:"getBigInt64",set:"setBigInt64"},BigUint64Array:{get:"getBigUint64",set:"setBigUint64"}}},r=t.getSysEndianness();class e extends Error{constructor(t){super(t),this.name="IntegrityError"}}class n{constructor(e,s,i=r,a=!1){if(this.littleEndian=i,"string"==typeof e&&(e=(new TextEncoder).encode(e)),this.constructor.isTypedArray(e))s&&(s=n.typeFromInput(s))!==e.constructor.name&&(e=this.constructor.convert(e,s,"force",i)),a&&(e=this.constructor.flipEndianness(e,!0)),this.updateArray=e;else{if(!(e instanceof ArrayBuffer||Array.isArray(e))){throw new TypeError(`${e?"":"An empty call is not possible.\n"}Allowed input types are: TypedArray, ArrayBuffer, Array, String`)}{let r=!0;if(s){s=n.typeFromInput(s);const i=t.ArrayTypes[s];(e instanceof ArrayBuffer||Array.isArray(e))&&(this.updateArray=new i(e),r=!1)}if(r)throw new TypeError("For Array and ArrayBuffer the type needs to be specified as a second argument.")}}}static getType(t){return t.constructor.name}static isTypedArray(r){return r.constructor.name in t.ArrayTypes}static isTypeOf(t,r){return r=n.typeFromInput(r),t.constructor.name===r}static typeFromInput(r){if("function"==typeof r&&(r=r.name),!(r in t.ArrayTypes)){if(!(r in t.ArrayShortCuts))throw new TypeError(`Unknown type: ${r}`);r=t.ArrayShortCuts[r]}return r}static get SYS_LITTLE_ENDIAN(){return r}static at(e,n,s=r,i=null){if(n=Number(n),isNaN(n))n=0;else if(n<0){if((n=e.length+n)<0)return}else if(n>=e.length)return;i=i||new DataView(e.buffer);const a=t.ViewMethods[e.constructor.name].get,o=n*e.BYTES_PER_ELEMENT;return i[a](o,s)}static clone(t){return t.slice()}static concat(r,...e){function s(t){return!!e.includes(t)&&(e.splice(e.indexOf(t),1),!0)}function i(t){throw new TypeError(`Your provided input is not a TypedArray: "${t}" (${t.constructor.name})`)}let a=s("force"),o=s("trim");s("purge")&&(o="purge");let l=!1;if(s("intMode")&&(l=!0),s("intForce")&&(l="force"),a||(a=Boolean(l)),n.isTypedArray(r)){if(!e.length)return r}else i(r);const u=r.constructor.name;let h=[...r];return e.forEach((t=>{n.isTypedArray(t)||i(t);let r=t;if(t.constructor.name!==u){if(!a)throw new TypeError(`\n                        You are trying to concatenate different types of arrays:\n                        > "${u}" and "${t.constructor.name}" <\n                        You can force this, by passing the string "force" to the function call.\n                    `.replace(/ +/gu," "));r=n.convert(t,u,l,o)}h=h.concat([...r])})),t.ArrayTypes[u].from(h)}static convert(s,i,a=!1,o=!1,l=r,u=null){function h(t,r){return r?BigInt(t):Number(t)}let c;if(i=n.typeFromInput(i),a){const r=s.BYTES_PER_ELEMENT,n=t.ArrayTypes[i].BYTES_PER_ELEMENT,o=Math.max(r-n,0),y="force"!==a&&o;u=u||new DataView(s.buffer),c=new t.ArrayTypes[i](s.length);const E=new DataView(c.buffer),f=t.ViewMethods[s.constructor.name].get,p=t.ViewMethods[i].get,d=t.ViewMethods[i].set,A=n>7;for(let t=0;t<s.length;t++){const s=t*r,i=h(u[f](s,l),A);if(y){if(i!==h(u[p](s,l),A))throw new e("Converting the array will cause data loss. If you explicitly want this, pass the string 'force' to param intMode")}const a=t*n;E[d](a,i,l)}}else{const r=s.byteLength,e=r%t.ArrayTypes[i].BYTES_PER_ELEMENT;if(e){const n=t.ArrayTypes[i].BYTES_PER_ELEMENT-e;let a=new Uint8Array(r+n);c=new t.ArrayTypes[i](a.buffer);const o=s.BYTES_PER_ELEMENT>1?new Uint8Array(s.buffer):s,u=l?0:n;a.set(o,u)}else c=new t.ArrayTypes[i](s.buffer),o&&(c=n.trim(c,"purge"===o,l))}return c}static detach(t,e,s=r){let i,a;return e=Math.min(e,t.length-1),[a,i]=n.splice(t,e,1,s),s!==r&&n.flipEndianness(i),[a,i.at(0)]}static flipEndianness(t,r=!1){r&&(t=t.slice());const e=t.constructor.BYTES_PER_ELEMENT;if(e>1){const r=new Uint8Array(t.buffer);for(let n=0;n<t.byteLength;n+=e)r.subarray(n,n+e).reverse()}return t}static flipEndiannessInt(r,e){e=n.typeFromInput(e);const s=new t.ArrayTypes[e](1);return s[0]=r,n.flipEndianness(s),s[0]}static from(t,e,s=r,i=!1){return new n(t,e,s,i)}static insert(t,e,s,i=r){e<0?e=Math.max(t.length+e+1,0):e>t.length&&(e=t.length);const a=n.splice(t,e,0,s,i)[0];return[a,a.length]}static pop(e,n=r,s=null){s=s||new DataView(e.buffer);const i=t.ViewMethods[e.constructor.name].get,a=(e.length-1)*e.BYTES_PER_ELEMENT,o=s[i](a,n);return[e.slice(0,-1),o]}static push(t,...r){const e=n.splice(t,t.length,0,...r)[0];return[e,e.length]}static setAt(e,n,s,i=r,a=null){n<0?n=Math.max(e.length+n,0):n>=e.length&&(n=e.length-1);const o=e.constructor.name;(a=a||new DataView(e.buffer))[t.ViewMethods[o].set](n*e.BYTES_PER_ELEMENT,s,i)}static shift(e,n=r,s=null){const i=(s=s||new DataView(e.buffer))[t.ViewMethods[e.constructor.name].get](0,n);return[e.slice(1),i]}static splice(e,s,i,...a){const o=e.constructor.name,l=e.length;Number.isInteger(s)?s<0&&(s=Math.max(l+s,0)):s=l,i=(s=Math.min(s,l))===l?0:!Number.isInteger(i)||i>=l-s?l-s:Math.max(i,0);const u="boolean"==typeof a.at(-1)?a.splice(-1,1)[0]:r,h=s+i,c=e.subarray(0,s),y=e.slice(s,h),E=e.subarray(h,l);let f;const p=t.ViewMethods[o].set;if(a.length){const r=new t.ArrayTypes[o](a.length),e=new DataView(r.buffer),s=r.BYTES_PER_ELEMENT;for(let t=0,r=a.length;t<r;t++)e[p](t*s,a[t],u);f=n.concat(c,r,E)}else f=n.concat(c,E);return[f,y]}static trim(t,e=!1,n=r){if(e)return t.filter((t=>0!==t));const s=t.length;let i=0,a=s-1;if(n)for(;a>=0&&!t[a];a--);else for(;i<s&&!t[i];i++);return t.slice(i,a+1)}static unshift(t,...r){const e=n.splice(t,0,0,...r)[0];return[e,e.length]}set updateArray(t){this.array=t,this.view=new DataView(t.buffer)}get[Symbol.species](){return t.ArrayTypes[this.type]}get buffer(){return this.array.buffer}get byteLength(){return this.array.byteLength}get byteOffset(){return this.array.byteOffset}get length(){return this.array.length}get type(){return this.array.constructor.name}get BYTES_PER_ELEMENT(){return this.array.BYTES_PER_ELEMENT}get SYS_LITTLE_ENDIAN(){return r}#t(t){return null===t?this.littleEndian:Boolean(t)}#r(t,r,e,n){return(n=this.#t(n))!==this.SYS_LITTLE_ENDIAN&&(r=this.constructor.flipEndiannessInt(r,this.type)),this.array[t](r,e)}#e(r,e,n=null){e&&(r=r.bind(e)),null===n&&(n=this.littleEndian);const s=t.ViewMethods[this.type].get;for(let t=0;t<this.array.length;t++){const e=t*this.BYTES_PER_ELEMENT,i=this.view[s](e,n);if(r(i,t,this.array))return{bool:!0,index:t,value:i}}return{bool:!1,index:-1,value:void 0}}at(t,r=null){return r=this.#t(r),this.constructor.at(this.array,t,r,this.view)}clone(){return new n(this.array.slice(),null,this.littleEndian)}concat(...t){const r=this.constructor.concat(this.array,...t);return new n(r)}convert(t,r=!1,e=!1){return t=this.constructor.typeFromInput(t),this.updateArray=this.constructor.convert(this.array,t,r,e,this.littleEndian,this.view),this.array}conset(t){this.updateArray=this.concat(t).array}copyWithin(t,r,e){return this.array.copyWithin(t,r,e)}detach(t,r=null){let e;return r=this.#t(r),[this.updateArray,e]=this.constructor.detach(this.array,t,r),e}*entries(r=null){r=this.#t(r);const e=t.ViewMethods[this.type].get;for(let t=0;t<this.array.length;t++){const n=t*this.BYTES_PER_ELEMENT,s=[t,this.view[e](n,r)];yield s}}every(r,e,n=null){e&&(r=r.bind(e)),n=this.#t(n);const s=t.ViewMethods[this.type].get;for(let t=0;t<this.array.length;t++){const e=t*this.BYTES_PER_ELEMENT;if(!r(this.view[s](e,n),t,this.array))return!1}return!0}extractArrayClone(t=!1){const r=this.array.slice();return t&&this.littleEndian!==this.SYS_LITTLE_ENDIAN&&this.constructor.flipEndianness(r),r}fill(t,r,e,n=null){return(n=this.#t(n))!==this.SYS_LITTLE_ENDIAN&&(t=this.constructor.flipEndiannessInt(t,this.type)),this.array.fill(t,r,e)}filter(r,e,n=null){n=this.#t(n);const s=[];this.map((function(t,e,n){r.call(this,t,e,n)&&s.push(t)}),e,n);return t.ArrayTypes[this.type].from(s)}find(t,r,e=null){return this.#e(t,r,e).value}findIndex(t,r,e=null){return this.#e(t,r,e).index}flipEndianness(t=!0){return this.updateArray=this.constructor.flipEndianness(this.array),t&&(this.littleEndian=!this.littleEndian),this.array}forEach(t,r,e=null){this.map(t,r,e)}includes(t,r,e=null){return this.#r("includes",t,r,e)}indexOf(t,r,e=null){return this.#r("indexOf",t,r,e)}insert(t,r,e=null){let n;return e=this.#t(e),[this.updateArray,n]=this.constructor.insert(this.array,t,r,e),n}join(t=",",r=null){return r=this.#t(r),[...this.values(r)].join(t)}keys(){return this.array.keys()}lastIndexOf(t,r=Number.MAX_SAFE_INTEGER,e=null){return this.#r("lastIndexOf",t,r,e)}map(r,e,n=null){e&&(r=r.bind(e)),n=this.#t(n);const s=new t.ArrayTypes[this.type](this.length),i=new DataView(s.buffer),a=t.ViewMethods[this.type];for(let t=0;t<this.array.length;t++){const e=t*this.BYTES_PER_ELEMENT,s=this.view[a.get](e,n),o=parseInt(r(s,t,this.array),10)||0;i[a.set](e,o,n)}return s}pop(t=null){let r;return t=this.#t(t),[this.updateArray,r]=this.constructor.pop(this.array,t,this.view),r}push(...t){let r;return"boolean"!=typeof t.at(-1)&&t.push(this.littleEndian),[this.updateArray,r]=this.constructor.push(this.array,...t),r}reduce(t,r=null,e=null){return[...this.values(e)].reduce(t,r)}reduceRight(t,r=null,e=null){return[...this.values(e)].reduceRight(t,r)}reverse(){return this.array.reverse()}set(r,e,n=null){let s;n=this.#t(n),Array.isArray(r)&&(s=new t.ArrayTypes[this.type](r)),n!==this.SYS_LITTLE_ENDIAN&&(s||(s=r.slice()),this.constructor.flipEndianness(s)),s||(s=r),this.array.set(s,e)}setAt(t,r,e=null){e=this.#t(e),this.constructor.setAt(this.array,t,r,e,this.view)}shift(t=null){let r;return t=this.#t(t),[this.updateArray,r]=this.constructor.shift(this.array,t,this.view),r}slice(t,r){return this.array.slice(t,r)}some(t,r,e=null){return this.#e(t,r,e).bool}sort(t,r=null){if((r=this.#t(r))!==this.SYS_LITTLE_ENDIAN){const r=this.extractArrayClone();this.constructor.flipEndianness(r),r.sort(t),this.constructor.flipEndianness(r),this.array.set(r)}else this.array.sort(t);return this.array}splice(t,r,...e){let n;return"boolean"!=typeof e.at(-1)&&e.push(this.littleEndian),[this.updateArray,n]=this.constructor.splice(this.array,t,r,...e),n}subarray(t,r){return this.array.subarray(t,r)}toLocaleString(t=null){return t=this.#t(t),[...this.values(t)].toLocaleString()}toString(t=null){return[...this.values(t)].toString()}trim(t=!1,r=null){r=this.#t(r),this.updateArray=this.constructor.trim(this.array,t,r)}unshift(...t){let r;return"boolean"!=typeof t.at(-1)&&t.push(this.littleEndian),[this.updateArray,r]=this.constructor.unshift(this.array,...t),r}*values(t=null){t=this.#t(t);const r=this.entries(t);for(const t of r)yield t[1]}}export{n as default};
